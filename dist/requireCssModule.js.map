{"version":3,"sources":["../src/requireCssModule.js"],"names":["getFiletypeOptions","cssSourceFilePath","filetypes","extension","substr","lastIndexOf","filetype","getSyntax","filetypeOptions","syntax","require","getExtraPlugins","plugins","map","plugin","getTokens","runner","options","from","lazyResult","process","warnings","forEach","message","console","warn","text","root","tokens","generateScopedName","context","cwd","fetch","to","fromDirectoryPath","toPath","extraPlugins"],"mappings":";;;;;;AAEA;;AAIA;;AAGA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAeA,MAAMA,qBAAqB,CAACC,iBAAD,EAA4BC,SAA5B,KAA4F;AACrH,QAAMC,YAAYF,kBAAkBG,MAAlB,CAAyBH,kBAAkBI,WAAlB,CAA8B,GAA9B,CAAzB,CAAlB;AACA,QAAMC,WAAWJ,YAAYA,UAAUC,SAAV,CAAZ,GAAmC,IAApD;;AAEA,SAAOG,QAAP;AACD,CALD;;AAOA;;;AACA,MAAMC,YAAaC,eAAD,IAAgE;AAChF,MAAI,CAACA,eAAD,IAAoB,CAACA,gBAAgBC,MAAzC,EAAiD;AAC/C,WAAO,IAAP;AACD;;AAED;AACA,SAAOC,QAAQF,gBAAgBC,MAAxB,CAAP;AACD,CAPD;;AASA;AACA,MAAME,kBAAmBH,eAAD,IAA8D;AACpF,MAAI,CAACA,eAAD,IAAoB,CAACA,gBAAgBI,OAAzC,EAAkD;AAChD,WAAO,EAAP;AACD;;AAED,SAAOJ,gBAAgBI,OAAhB,CAAwBC,GAAxB,CAA6BC,MAAD,IAAY;AAC7C;AACA,WAAOJ,QAAQI,MAAR,CAAP;AACD,GAHM,CAAP;AAID,CATD;;AAWA,MAAMC,YAAY,CAACC,MAAD,EAASf,iBAAT,EAAoCO,eAApC,KAAkG;AAClH;AACA,QAAMS,UAAkB;AACtBC,UAAMjB;AADgB,GAAxB;;AAIA,MAAIO,eAAJ,EAAqB;AACnBS,YAAQR,MAAR,GAAiBF,UAAUC,eAAV,CAAjB;AACD;;AAED,QAAMW,aAAaH,OAChBI,OADgB,CACR,sBAAanB,iBAAb,EAAgC,OAAhC,CADQ,EACkCgB,OADlC,CAAnB;;AAGAE,aACGE,QADH,GAEGC,OAFH,CAEYC,OAAD,IAAa;AACpB;AACAC,YAAQC,IAAR,CAAaF,QAAQG,IAArB;AACD,GALH;;AAOA,SAAOP,WAAWQ,IAAX,CAAgBC,MAAvB;AACD,CArBD;;kBA6Be,CAAC3B,iBAAD,EAA4BgB,OAA5B,KAAyE;AACtF;AACA,MAAID,MAAJ;;AAEA,MAAIa,kBAAJ;;AAEA,MAAIZ,QAAQY,kBAAR,IAA8B,OAAOZ,QAAQY,kBAAf,KAAsC,UAAxE,EAAoF;AAClFA,yBAAqBZ,QAAQY,kBAA7B;AACD,GAFD,MAEO;AACLA,yBAAqB,4BAAaZ,QAAQY,kBAAR,IAA8B,4CAA3C,EAAyF;AAC5GC,eAASb,QAAQa,OAAR,IAAmBV,QAAQW,GAAR;AADgF,KAAzF,CAArB;AAGD;;AAED,QAAMvB,kBAAkBR,mBAAmBC,iBAAnB,EAAsCgB,QAAQf,SAA9C,CAAxB;;AAEA,QAAM8B,QAAQ,CAACC,EAAD,EAAaf,IAAb,KAA8B;AAC1C,UAAMgB,oBAAoB,mBAAQhB,IAAR,CAA1B;AACA,UAAMiB,SAAS,mBAAQD,iBAAR,EAA2BD,EAA3B,CAAf;;AAEA,WAAOlB,UAAUC,MAAV,EAAkBmB,MAAlB,EAA0B3B,eAA1B,CAAP;AACD,GALD;;AAOA,QAAM4B,eAAezB,gBAAgBH,eAAhB,CAArB;;AAEA,QAAMI,UAAU,CACd,GAAGwB,YADW,kHAKd,kCAAU;AACRP;AADQ,GAAV,CALc,EAQd,mCAAW;AACTG;AADS,GAAX,CARc,CAAhB;;AAaAhB,WAAS,uBAAQJ,OAAR,CAAT;;AAEA,SAAOG,UAAUC,MAAV,EAAkBf,iBAAlB,EAAqCO,eAArC,CAAP;AACD,C","file":"requireCssModule.js","sourcesContent":["// @flow\r\n\r\nimport {\r\n  dirname,\r\n  resolve\r\n} from 'path';\r\nimport {\r\n  readFileSync\r\n} from 'fs';\r\nimport postcss from 'postcss';\r\nimport genericNames from 'generic-names';\r\nimport ExtractImports from 'postcss-modules-extract-imports';\r\nimport LocalByDefault from 'postcss-modules-local-by-default';\r\nimport Parser from 'postcss-modules-parser';\r\nimport Scope from 'postcss-modules-scope';\r\nimport Values from 'postcss-modules-values';\r\nimport type {\r\n  GenerateScopedNameConfigurationType,\r\n  StyleModuleMapType\r\n} from './types';\r\n\r\ntype FiletypeOptionsType = {|\r\n  +syntax: string,\r\n  +plugins?: $ReadOnlyArray<string>\r\n|};\r\n\r\ntype FiletypesConfigurationType = {\r\n  [key: string]: FiletypeOptionsType\r\n};\r\n\r\nconst getFiletypeOptions = (cssSourceFilePath: string, filetypes: FiletypesConfigurationType): ?FiletypeOptionsType => {\r\n  const extension = cssSourceFilePath.substr(cssSourceFilePath.lastIndexOf('.'));\r\n  const filetype = filetypes ? filetypes[extension] : null;\r\n\r\n  return filetype;\r\n};\r\n\r\n// eslint-disable-next-line flowtype/no-weak-types\r\nconst getSyntax = (filetypeOptions: FiletypeOptionsType): ?(Function | Object) => {\r\n  if (!filetypeOptions || !filetypeOptions.syntax) {\r\n    return null;\r\n  }\r\n\r\n  // eslint-disable-next-line import/no-dynamic-require, global-require\r\n  return require(filetypeOptions.syntax);\r\n};\r\n\r\n// eslint-disable-next-line flowtype/no-weak-types\r\nconst getExtraPlugins = (filetypeOptions: ?FiletypeOptionsType): $ReadOnlyArray<*> => {\r\n  if (!filetypeOptions || !filetypeOptions.plugins) {\r\n    return [];\r\n  }\r\n\r\n  return filetypeOptions.plugins.map((plugin) => {\r\n    // eslint-disable-next-line import/no-dynamic-require, global-require\r\n    return require(plugin);\r\n  });\r\n};\r\n\r\nconst getTokens = (runner, cssSourceFilePath: string, filetypeOptions: ?FiletypeOptionsType): StyleModuleMapType => {\r\n  // eslint-disable-next-line flowtype/no-weak-types\r\n  const options: Object = {\r\n    from: cssSourceFilePath\r\n  };\r\n\r\n  if (filetypeOptions) {\r\n    options.syntax = getSyntax(filetypeOptions);\r\n  }\r\n\r\n  const lazyResult = runner\r\n    .process(readFileSync(cssSourceFilePath, 'utf-8'), options);\r\n\r\n  lazyResult\r\n    .warnings()\r\n    .forEach((message) => {\r\n      // eslint-disable-next-line no-console\r\n      console.warn(message.text);\r\n    });\r\n\r\n  return lazyResult.root.tokens;\r\n};\r\n\r\ntype OptionsType = {|\r\n  filetypes: FiletypesConfigurationType,\r\n  generateScopedName?: GenerateScopedNameConfigurationType,\r\n  context?: string\r\n|};\r\n\r\nexport default (cssSourceFilePath: string, options: OptionsType): StyleModuleMapType => {\r\n  // eslint-disable-next-line prefer-const\r\n  let runner;\r\n\r\n  let generateScopedName;\r\n\r\n  if (options.generateScopedName && typeof options.generateScopedName === 'function') {\r\n    generateScopedName = options.generateScopedName;\r\n  } else {\r\n    generateScopedName = genericNames(options.generateScopedName || '[path]___[name]__[local]___[hash:base64:5]', {\r\n      context: options.context || process.cwd()\r\n    });\r\n  }\r\n\r\n  const filetypeOptions = getFiletypeOptions(cssSourceFilePath, options.filetypes);\r\n\r\n  const fetch = (to: string, from: string) => {\r\n    const fromDirectoryPath = dirname(from);\r\n    const toPath = resolve(fromDirectoryPath, to);\r\n\r\n    return getTokens(runner, toPath, filetypeOptions);\r\n  };\r\n\r\n  const extraPlugins = getExtraPlugins(filetypeOptions);\r\n\r\n  const plugins = [\r\n    ...extraPlugins,\r\n    Values,\r\n    LocalByDefault,\r\n    ExtractImports,\r\n    new Scope({\r\n      generateScopedName\r\n    }),\r\n    new Parser({\r\n      fetch\r\n    })\r\n  ];\r\n\r\n  runner = postcss(plugins);\r\n\r\n  return getTokens(runner, cssSourceFilePath, filetypeOptions);\r\n};\r\n"]}