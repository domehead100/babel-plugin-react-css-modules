{"version":3,"sources":["../src/resolveStringLiteral.js"],"names":["path","styleModuleImportMap","styleNameAttribute","options","classNameAttribute","node","openingElement","attributes","find","attribute","name","resolvedStyleName","value","expression","Error","splice","indexOf"],"mappings":";;;;;;AAEA;;AAMA;;;;AACA;;;;;;AAUA;;;kBAGe,CAACA,IAAD,EAAUC,oBAAV,EAA0DC,kBAA1D,EAA4FC,OAA5F,KAA2H;AACxI,QAAMC,qBAAqBJ,KAAKK,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CACxBC,IADwB,CAClBC,SAAD,IAAe;AACnB,WAAO,OAAOA,UAAUC,IAAjB,KAA0B,WAA1B,IAAyCD,UAAUC,IAAV,CAAeA,IAAf,KAAwB,WAAxE;AACD,GAHwB,CAA3B;;AAKA,QAAMC,oBAAoB,4BAAaT,mBAAmBU,KAAnB,CAAyBA,KAAtC,EAA6CX,oBAA7C,EAAmEE,OAAnE,CAA1B;;AAEA,MAAIC,kBAAJ,EAAwB;AACtB,QAAI,iCAAgBA,mBAAmBQ,KAAnC,CAAJ,EAA+C;AAC7CR,yBAAmBQ,KAAnB,CAAyBA,KAAzB,IAAkC,MAAMD,iBAAxC;AACD,KAFD,MAEO,IAAI,0CAAyBP,mBAAmBQ,KAA5C,CAAJ,EAAwD;AAC7DR,yBAAmBQ,KAAnB,CAAyBC,UAAzB,GAAsC,qCACpCT,mBAAmBQ,KAAnB,CAAyBC,UADW,EAEpC,+BAAcF,iBAAd,CAFoC,CAAtC;AAID,KALM,MAKA;AACL,YAAM,IAAIG,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAEDd,SAAKK,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCQ,MAApC,CAA2Cf,KAAKK,IAAL,CAAUC,cAAV,CAAyBC,UAAzB,CAAoCS,OAApC,CAA4Cd,kBAA5C,CAA3C,EAA4G,CAA5G;AACD,GAbD,MAaO;AACLA,uBAAmBQ,IAAnB,CAAwBA,IAAxB,GAA+B,WAA/B;AACAR,uBAAmBU,KAAnB,CAAyBA,KAAzB,GAAiCD,iBAAjC;AACD;AACF,C","file":"resolveStringLiteral.js","sourcesContent":["// @flow\r\n\r\nimport {\r\n  isJSXExpressionContainer,\r\n  isStringLiteral,\r\n  JSXAttribute,\r\n  stringLiteral\r\n} from 'babel-types';\r\nimport conditionalClassMerge from './conditionalClassMerge';\r\nimport getClassName from './getClassName';\r\nimport type {\r\n  StyleModuleImportMapType,\r\n  HandleMissingStyleNameOptionType\r\n} from './types';\r\n\r\ntype OptionsType = {|\r\n  handleMissingStyleName: HandleMissingStyleNameOptionType\r\n|};\r\n\r\n/**\r\n * Updates the className value of a JSX element using a provided styleName attribute.\r\n */\r\nexport default (path: *, styleModuleImportMap: StyleModuleImportMapType, styleNameAttribute: JSXAttribute, options: OptionsType): void => {\r\n  const classNameAttribute = path.node.openingElement.attributes\r\n    .find((attribute) => {\r\n      return typeof attribute.name !== 'undefined' && attribute.name.name === 'className';\r\n    });\r\n\r\n  const resolvedStyleName = getClassName(styleNameAttribute.value.value, styleModuleImportMap, options);\r\n\r\n  if (classNameAttribute) {\r\n    if (isStringLiteral(classNameAttribute.value)) {\r\n      classNameAttribute.value.value += ' ' + resolvedStyleName;\r\n    } else if (isJSXExpressionContainer(classNameAttribute.value)) {\r\n      classNameAttribute.value.expression = conditionalClassMerge(\r\n        classNameAttribute.value.expression,\r\n        stringLiteral(resolvedStyleName)\r\n      );\r\n    } else {\r\n      throw new Error('Unexpected attribute value.');\r\n    }\r\n\r\n    path.node.openingElement.attributes.splice(path.node.openingElement.attributes.indexOf(styleNameAttribute), 1);\r\n  } else {\r\n    styleNameAttribute.name.name = 'className';\r\n    styleNameAttribute.value.value = resolvedStyleName;\r\n  }\r\n};\r\n"]}